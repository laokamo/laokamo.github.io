{"meta":{"title":"弯仔码头","subtitle":null,"description":null,"author":"laokamo","url":"https://www.laokamo.com"},"pages":[],"posts":[{"title":"ArrayList 源码阅读札记","slug":"ArrayList-源码阅读札记","date":"2018-03-03T05:21:00.000Z","updated":"2019-03-01T05:23:32.583Z","comments":true,"path":"2018/03/03/ArrayList-源码阅读札记/","link":"","permalink":"https://www.laokamo.com/2018/03/03/ArrayList-源码阅读札记/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325package java.util;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator;import sun.misc.SharedSecrets;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * 默认初始化容量. */ private static final int DEFAULT_CAPACITY = 10; /** * 指定该ArrayList容量为0时，返回该空数组. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存元素的对象数组. * ArrayList的容量就是这个数组的长度. * 该值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，当第一次添加元素进入ArrayList中时，数组将扩 * 容值DEFAULT_CAPACITY(10). */ transient Object[] elementData; // non-private to simplify nested class access /** * 数组中实际包含的元素个数. */ private int size; /** * 构造一个指定容量为initialCapacity的ArrayList. * * @param initialCapacity 初始化容量 * @throws IllegalArgumentException 如果initialCapacity&lt;0 抛出异常 */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; /** * 构造一个初始化容量为10的ArrayList. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 构造一个包含指定collection元素的ArrayList, * 按照迭代器返回给它们的顺序排列. * * @param c 要存入ArrayList的collection元素 * @throws NullPointerException 如果指定collection为空时 抛出异常 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; /** * 调整ArrayList的容量到当前元素个数. */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; /** * 扩容方法. * * @param minCapacity 期望的最小容量 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * 分派给arrays的最大容量 * 为什么要减去8呢？ * 因为某些VM会在数组中保留一些头字，尝试分配这个最大存储容量，可能会导致array容量大于VM的limit，最终导致OutOfMemoryError。 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * 扩容，保证ArrayList至少能存储minCapacity个元素 * * @param minCapacity 期望的最小容量 */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; /** * 进行大容量分配 */ private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** * 返回列表中包含的元素个数. * * @return the number of elements in this list */ public int size() &#123; return size; &#125; /** * 如果列表中没有元素 返回 true. * * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements */ public boolean isEmpty() &#123; return size == 0; &#125; /** * 如果包含指定元素o 则返回 true * * @param o element whose presence in this list is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element */ public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; /** * 返回第一次出现的元素下标,如果没有匹配则返回 -1 (从前往后) */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回第一次出现的元素下标,如果没有匹配则返回 -1 (从后往前) */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 浅拷贝 * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */ public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; /** * 将list转为数组 * 该方法需要申请分配新的数组空间 * 该方法用来连接 基于数组和基于集合的APIs桥梁 * * @return an array containing all of the elements in this list in * proper sequence */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * Returns an array containing all of the elements in this list in proper * sequence (from first to last element); the runtime type of the returned * array is that of the specified array. If the list fits in the * specified array, it is returned therein. Otherwise, a new array is * allocated with the runtime type of the specified array and the size of * this list. * * &lt;p&gt;If the list fits in the specified array with room to spare * (i.e., the array has more elements than the list), the element in * the array immediately following the end of the collection is set to * &lt;tt&gt;null&lt;/tt&gt;. (This is useful in determining the length of the * list &lt;i&gt;only&lt;/i&gt; if the caller knows that the list does not contain * any null elements.) * * @param a the array into which the elements of the list are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose. * @return an array containing the elements of the list * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this list * @throws NullPointerException if the specified array is null */ @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // Positional Access Operations @SuppressWarnings(\"unchecked\") E elementData(int index) &#123; return (E) elementData[index]; &#125; /** * 返回指定位置的元素. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; /** * 替换指定位置的元素.并返回旧值 * * @param index 替换的位置 * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; /** * 添加指定元素到队列尾部 * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 修改次数加1!! elementData[size++] = e; return true; &#125; /** * 插入指定位置的指定元素 * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** * 移除指定位置的元素，并返回旧值. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; /** * 移除首次碰见的指定值o,如果存在该值 返回true * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /* * 跳过边界检查，快速删除 */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * 清空元素 */ public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; /** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; /** * Removes from this list all of the elements whose index is between * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. * Shifts any succeeding elements to the left (reduces their index). * This call shortens the list by &#123;@code (toIndex - fromIndex)&#125; elements. * (If &#123;@code toIndex==fromIndex&#125;, this operation has no effect.) * * @throws IndexOutOfBoundsException if &#123;@code fromIndex&#125; or * &#123;@code toIndex&#125; is out of range * (&#123;@code fromIndex &lt; 0 || * fromIndex &gt;= size() || * toIndex &gt; size() || * toIndex &lt; fromIndex&#125;) */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; /** * 检查下标是否越界 */ private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * A version of rangeCheck used by add and addAll. */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * Constructs an IndexOutOfBoundsException detail message. * Of the many possible refactorings of the error handling code, * this \"outlining\" performs best with both server and client VMs. */ private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+size; &#125; /** * Removes from this list all of its elements that are contained in the * specified collection. * * @param c collection containing elements to be removed from this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=\"Collection.html#optional-restrictions\"&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=\"Collection.html#optional-restrictions\"&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125; /** * Retains only the elements in this list that are contained in the * specified collection. In other words, removes from this list all * of its elements that are not contained in the specified collection. * * @param c collection containing elements to be retained in this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=\"Collection.html#optional-restrictions\"&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=\"Collection.html#optional-restrictions\"&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */ public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; /** * 自定义序列化方法 * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * 反序列化方法 */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; /** * Returns a list iterator over the elements in this list (in proper * sequence), starting at the specified position in the list. * The specified index indicates the first element that would be * returned by an initial call to &#123;@link ListIterator#next next&#125;. * An initial call to &#123;@link ListIterator#previous previous&#125; would * return the element with the specified index minus one. * * &lt;p&gt;The returned list iterator is &lt;a href=\"#fail-fast\"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"Index: \"+index); return new ListItr(index); &#125; /** * Returns a list iterator over the elements in this list (in proper * sequence). * * &lt;p&gt;The returned list iterator is &lt;a href=\"#fail-fast\"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @see #listIterator(int) */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href=\"#fail-fast\"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @return an iterator over the elements in this list in proper sequence */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * An optimized version of AbstractList.ListItr */ private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * Returns a view of the portion of this list between the specified * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. (If * &#123;@code fromIndex&#125; and &#123;@code toIndex&#125; are equal, the returned list is * empty.) The returned list is backed by this list, so non-structural * changes in the returned list are reflected in this list, and vice-versa. * The returned list supports all of the optional list operations. * * &lt;p&gt;This method eliminates the need for explicit range operations (of * the sort that commonly exist for arrays). Any operation that expects * a list can be used as a range operation by passing a subList view * instead of a whole list. For example, the following idiom * removes a range of elements from a list: * &lt;pre&gt; * list.subList(from, to).clear(); * &lt;/pre&gt; * Similar idioms may be constructed for &#123;@link #indexOf(Object)&#125; and * &#123;@link #lastIndexOf(Object)&#125;, and all of the algorithms in the * &#123;@link Collections&#125; class can be applied to a subList. * * &lt;p&gt;The semantics of the list returned by this method become undefined if * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in * any way other than via the returned list. (Structural modifications are * those that change the size of this list, or otherwise perturb it in such * a fashion that iterations in progress may yield incorrect results.) * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); &#125; static void subListRangeCheck(int fromIndex, int toIndex, int size) &#123; if (fromIndex &lt; 0) throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex); if (toIndex &gt; size) throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") &gt; toIndex(\" + toIndex + \")\"); &#125; private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; public E set(int index, E e) &#123; rangeCheck(index); checkForComodification(); E oldValue = ArrayList.this.elementData(offset + index); ArrayList.this.elementData[offset + index] = e; return oldValue; &#125; public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; public int size() &#123; checkForComodification(); return this.size; &#125; public void add(int index, E e) &#123; rangeCheckForAdd(index); checkForComodification(); parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; &#125; public E remove(int index) &#123; rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; &#125; protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(this.size, c); &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; checkForComodification(); parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return cursor != SubList.this.size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; &#125; @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = SubList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[offset + (i++)]); &#125; // update once at end of iteration to reduce heap write traffic lastRet = cursor = i; checkForComodification(); &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(offset + lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); &#125; &#125;; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, offset, fromIndex, toIndex); &#125; private void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+this.size; &#125; private void checkForComodification() &#123; if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); &#125; public Spliterator&lt;E&gt; spliterator() &#123; checkForComodification(); return new ArrayListSpliterator&lt;E&gt;(ArrayList.this, offset, offset + this.size, this.modCount); &#125; &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Creates a &lt;em&gt;&lt;a href=\"Spliterator.html#binding\"&gt;late-binding&lt;/a&gt;&lt;/em&gt; * and &lt;em&gt;fail-fast&lt;/em&gt; &#123;@link Spliterator&#125; over the elements in this * list. * * &lt;p&gt;The &#123;@code Spliterator&#125; reports &#123;@link Spliterator#SIZED&#125;, * &#123;@link Spliterator#SUBSIZED&#125;, and &#123;@link Spliterator#ORDERED&#125;. * Overriding implementations should document the reporting of additional * characteristic values. * * @return a &#123;@code Spliterator&#125; over the elements in this list * @since 1.8 */ @Override public Spliterator&lt;E&gt; spliterator() &#123; return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0); &#125; /** Index-based split-by-two, lazily initialized Spliterator */ static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; &#123; /* * If ArrayLists were immutable, or structurally immutable (no * adds, removes, etc), we could implement their spliterators * with Arrays.spliterator. Instead we detect as much * interference during traversal as practical without * sacrificing much performance. We rely primarily on * modCounts. These are not guaranteed to detect concurrency * violations, and are sometimes overly conservative about * within-thread interference, but detect enough problems to * be worthwhile in practice. To carry this out, we (1) lazily * initialize fence and expectedModCount until the latest * point that we need to commit to the state we are checking * against; thus improving precision. (This doesn't apply to * SubLists, that create spliterators with current non-lazy * values). (2) We perform only a single * ConcurrentModificationException check at the end of forEach * (the most performance-sensitive method). When using forEach * (as opposed to iterators), we can normally only detect * interference after actions, not before. Further * CME-triggering checks apply to all other possible * violations of assumptions for example null or too-small * elementData array given its size(), that could only have * occurred due to interference. This allows the inner loop * of forEach to run without any further checks, and * simplifies lambda-resolution. While this does entail a * number of checks, note that in the common case of * list.stream().forEach(a), no checks or other computation * occur anywhere other than inside forEach itself. The other * less-often-used methods cannot take advantage of most of * these streamlinings. */ private final ArrayList&lt;E&gt; list; private int index; // current index, modified on advance/split private int fence; // -1 until used; then one past last index private int expectedModCount; // initialized when fence set /** Create new spliterator covering the given range */ ArrayListSpliterator(ArrayList&lt;E&gt; list, int origin, int fence, int expectedModCount) &#123; this.list = list; // OK if null unless traversed this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; &#125; private int getFence() &#123; // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) ArrayList&lt;E&gt; lst; if ((hi = fence) &lt; 0) &#123; if ((lst = list) == null) hi = fence = 0; else &#123; expectedModCount = lst.modCount; hi = fence = lst.size; &#125; &#125; return hi; &#125; public ArrayListSpliterator&lt;E&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid) ? null : // divide range in half unless too small new ArrayListSpliterator&lt;E&gt;(list, lo, index = mid, expectedModCount); &#125; public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; if (action == null) throw new NullPointerException(); int hi = getFence(), i = index; if (i &lt; hi) &#123; index = i + 1; @SuppressWarnings(\"unchecked\") E e = (E)list.elementData[i]; action.accept(e); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; return false; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst; Object[] a; if (action == null) throw new NullPointerException(); if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) &#123; if ((hi = fence) &lt; 0) &#123; mc = lst.modCount; hi = lst.size; &#125; else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) &#123; for (; i &lt; hi; ++i) &#123; @SuppressWarnings(\"unchecked\") E e = (E) a[i]; action.accept(e); &#125; if (lst.modCount == mc) return; &#125; &#125; throw new ConcurrentModificationException(); &#125; public long estimateSize() &#123; return (long) (getFence() - index); &#125; public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; &#125; &#125; @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings(\"unchecked\") final E element = (E) elementData[i]; if (filter.test(element)) &#123; removeSet.set(i); removeCount++; &#125; &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; if (anyToRemove) &#123; final int newSize = size - removeCount; for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; for (int k=newSize; k &lt; size; k++) &#123; elementData[k] = null; // Let gc do its work &#125; this.size = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove; &#125; @Override @SuppressWarnings(\"unchecked\") public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; elementData[i] = operator.apply((E) elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; @Override @SuppressWarnings(\"unchecked\") public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125;&#125;","categories":[],"tags":[{"name":"集合框架","slug":"集合框架","permalink":"https://www.laokamo.com/tags/集合框架/"},{"name":"Java","slug":"Java","permalink":"https://www.laokamo.com/tags/Java/"}]},{"title":"Nginx出现413 Request Entity Too Large错误解决方法","slug":"Nginx出现413-Request-Entity-Too-Large错误解决方法","date":"2016-10-21T14:20:41.000Z","updated":"2019-02-22T08:23:05.834Z","comments":true,"path":"2016/10/21/Nginx出现413-Request-Entity-Too-Large错误解决方法/","link":"","permalink":"https://www.laokamo.com/2016/10/21/Nginx出现413-Request-Entity-Too-Large错误解决方法/","excerpt":"","text":"最近公司有一个CMS项目，上传应用APK包时，小于1M的文件上传没问题，大于1M的文件会提示413 Request Entity Too Large错误。 一顿百度后发现，原来是Nginx限制了上传文件的大小(默认为1M)，在nginx中可以配置最大允许的文件大小 查看nginx文档 123Syntax:client_max_body_size size;Default:client_max_body_size 1m;Context: http, server, location Sets the maximum allowed size of the client request body, specified in the “Content-Length” request header field. If the size in a request exceeds the configured value, the 413 (Request Entity Too Large) error is returned to the client. Please be aware that browsers cannot correctly display this error. Setting size to 0 disables checking of client request body size. 那么解决起来就很简单了 1.打开配置文件 vim /conf/nginx.conf2.找到http{}3.添加client_max_body_size 200m; 这里改为200m，因为公司APK应用包基本100多m4.保存配置文件，并重启 ./nginx -s reload","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.laokamo.com/tags/Nginx/"}]},{"title":"Head First Java读书笔记(十四)——集合与泛型","slug":"Head-First-Java读书笔记-十四-——集合与泛型","date":"2014-06-08T05:38:21.000Z","updated":"2019-02-24T13:00:09.516Z","comments":true,"path":"2014/06/08/Head-First-Java读书笔记-十四-——集合与泛型/","link":"","permalink":"https://www.laokamo.com/2014/06/08/Head-First-Java读书笔记-十四-——集合与泛型/","excerpt":"","text":"常见的集合类型，有序的集合中的元素必须是可比较的，Comparable的： TreeSet：有序且防止重复的集合。HashMap：Key-Value集合，Key不可重复HashSet：防止重复的集合，可快速找到相符元素LinkedList：针对经常插入或者删除中间元素所涉及的高效率集合（不如ArrayList实用）LinkedHashMap：可记住元素插入顺序，可设定依照原宿上次存储先后来排序的HashMap。ArrayList中的sort()方法，可进行已实现了Comparable接口的类的排序，也可以使用实现了Comparator接口的内部类来进行排序。1234567891011121314151617181920// 实现Comparable接口class Song inplements Comparable&lt;Song&gt;&#123; public int compareTo(Song s)&#123; return title. compareTo(s.getTitle()); &#125;&#125;// 实现Comparatorclass Song&#123; class ArtistCompare implements Comparator&lt;Song&gt;&#123; public int Compare (Song one, Song two)&#123; return one.getArtist().compareTo(two.getArtist()); &#125; ArtistCompare artistCompare = new ArtistCompare(); Collections.sort(songList, artistCompare); &#125;&#125; 如果equal()被覆盖过，hashCode()方法也应该相应覆盖。equal()默认行为是执行==的比较，即判断两个引用变量是否引用堆中的同一个对象。如果equals()没有被覆盖过，那么两个对象永远不会被视为相等的。a.equals(b)必须与a.hashCode()==b.hashCode()等值，但a.hashCode()==b.hashCode() 不一定与a.equals(b)等值。","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(十三)——网络与线程","slug":"Head-First-Java读书笔记-十三-——网络与线程","date":"2014-05-31T05:38:21.000Z","updated":"2019-02-24T12:06:50.705Z","comments":true,"path":"2014/05/31/Head-First-Java读书笔记-十三-——网络与线程/","link":"","permalink":"https://www.laokamo.com/2014/05/31/Head-First-Java读书笔记-十三-——网络与线程/","excerpt":"","text":"服务器与客户端通过socket连接来沟通。 当ServerSocket接收到请求时，会在另外的一个端口做一个socket连接来处理客户端的请求。 线程代表独立的执行空间。 多线程同时执行时，实际上是多个线程随机轮流执行的。 线程进入可执行状态时，会在执行中和可执行这两种状态中切换。但是也可能进入堵塞状态。堵塞状态可能是闲置、等待其他县城完成、等待串流数据、等待被占用的对象等原因引起的。 构造线程时需要传入一个任务对象，这个任务对象需要实现Runnable接口。 123456//1.建立线程任务Runnable threadJob = new MyRunnable();//2.建立Thread对象(执行人员)并赋值Runable(任务)Thread myThread = new Thread(threadJob);//3.启动任务myThread.start(); 并发：不同线程对同一个对象同时进行处理，可能引起问题。 锁(synchronized) 要让对象在线程上有足够的安全性，就要对不可分割执行的指令上锁（同步化）。 如果线程尝试进入同步化的方法，必须取得对象的钥匙如果钥匙被别的线程拿走了，线程只能等待。 如果两个线程互相持有对方正在等待执行的方法的钥匙，就会发生死锁。","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(十二)——序列化和文件的输入/输出","slug":"Head-First-Java读书笔记-十二-——序列化和文件的输入-输出","date":"2014-05-03T04:16:21.000Z","updated":"2019-02-23T05:26:47.561Z","comments":true,"path":"2014/05/03/Head-First-Java读书笔记-十二-——序列化和文件的输入-输出/","link":"","permalink":"https://www.laokamo.com/2014/05/03/Head-First-Java读书笔记-十二-——序列化和文件的输入-输出/","excerpt":"","text":"将序列化对象写入文件12345678//创建出FileOutputStreamFileOutputStream fileStream = new FileOutputStream(\"MyGame.ser\");//创建ObjectOutputStreamObjectOutputStream os = new ObjectOutputStream(fileStream);//写入对象os.writeObject(characterOne);//关闭os.close(); 当对象被序列化时，被该对象引用的实例变量也会被序列化 Serializable Serializable接口又被称为marker或tag类的标记用接口，没有任何方法需要实现。它的唯一目的就是声明有实现它的类时可以被序列化的。 transient(瞬时) 如果某实例变量不能或不应该被序列化，就把它标记。 解序列化(Deserialization) 12345678910//创建出FileInputStreamFileInputStream fileStream = new FileInputStream(\"MyGame.ser\");//创建ObjectInputStreamObjectInputStream os = new ObjectInputStream(fileStream);//读取对象Object one = os.readObject();//转换对象GameCharacter elf = (GameCharacter) one;//关闭os.close(); 读取对象的顺序必须与写入的顺序相同 静态变量不会被序列化，因为所有对象都共享同一份静态变量值 serialVersionUId 序列化的识别 当Java尝试要还原对象时，它会对比对象与Java虚拟机上的类的serialVersionUId。如果不同，还原操作就会失败使用serialver 类名来取得版本ID","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(十一)——异常处理","slug":"Head-First-Java读书笔记-十一-——异常处理","date":"2014-04-27T03:16:21.000Z","updated":"2019-02-23T03:38:28.193Z","comments":true,"path":"2014/04/27/Head-First-Java读书笔记-十一-——异常处理/","link":"","permalink":"https://www.laokamo.com/2014/04/27/Head-First-Java读书笔记-十一-——异常处理/","excerpt":"","text":"调用有风险的方法时会发生什么？ 1.假设你调用了一个不是自己写的方法；2.该方法执行某些风险的任务，可能会在运行期间出状况；3.你必须认识到该方法的风险；4.你得写出可以在发生状况时加以处理的程序代码，未雨绸缪！ thorws 声明在方法上 throw 声明在catch中 try/catch12345try&#123; //危险动作&#125;catch(Exception ex)&#123; //尝试恢复&#125; 异常时一种Exception类型的对象 编译器会核对每件事，除了RuntimeExceptions 编译器所关心的时称为检查异常的异常。 finally 用来存放不管有没有异常都要执行的程序 流程 1.如果try块失败了，抛出异常，流程会马上转移到catch块。当catch块完成时，会执行finally块，当finally块完成时，就会继续执行其余部分。2.如果try块成功，流程会跳过catch块并移动到finally块，当finally完成时，就会继续执行其余的部分。3.如果try或catch块有return指令，finally还是会执行！程序会跳到finally然后再回到return指令 有多个catch块时要从小排到大","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(十)——数字和静态","slug":"Head-First-Java读书笔记-十-——数字和静态","date":"2014-04-26T02:40:35.000Z","updated":"2019-02-23T03:13:09.648Z","comments":true,"path":"2014/04/26/Head-First-Java读书笔记-十-——数字和静态/","link":"","permalink":"https://www.laokamo.com/2014/04/26/Head-First-Java读书笔记-十-——数字和静态/","excerpt":"","text":"静态方法 一种不依靠实例变量也不需要对象的行为 例如: Math.min(88,86)静态的方法不能调用非静态的变量，因为静态的方法是通过类名来调用，所以静态的方法无法引用到该类的任何实例变量静态方法不能调用非静态的方法 静态变量 它的值对所有的实例来说都是相同的同一类所有的实例共享一份静态变量静态变量会在该类的任何静态方法执行之前就初始化 实例变量：每个实例一份静态变量：每个类一份 final关键字 final变量代表你不能改变它的值final方法代表你不能覆盖掉该方法final的类代表你不能集成该类(也就是创建它的子类) 常量 一个被标记为final的变量代表它一旦被初始化之后就不会改动，也就是说类加载之后静态final变量就会一直维持原值常量变量的名称应该都要大写字母","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(九)——构造器与垃圾收集器","slug":"Head-First-Java读书笔记-九-——构造器与垃圾收集器","date":"2014-04-20T06:40:51.000Z","updated":"2019-02-22T08:17:49.094Z","comments":true,"path":"2014/04/20/Head-First-Java读书笔记-九-——构造器与垃圾收集器/","link":"","permalink":"https://www.laokamo.com/2014/04/20/Head-First-Java读书笔记-九-——构造器与垃圾收集器/","excerpt":"","text":"注意：内容含有死亡成份，12岁一下儿童需有家长陪同观赏对象有生死 栈(Stack) 方法调用和局部变量 堆(Heap) 所有的对象 实例变量 实例变量是被声明在类里而不是方法里面。它们代表每一个独立对象的’字段’。实例变量存在于所属的对象中。 局部变量 局部变量和方法的参数都是被声明在方法中。它们是暂时的，且声明周期只限于方法被放在栈上的的这段期间。 当调用一个方法时，该方法会放在调用栈的栈顶，实际被堆上栈的是堆栈块，它带有方法的状态，包括执行到哪一行程序以及所有的局部变量的值。 对象引用变量与基本数据类型都放在栈上。不管是实例变量或者局部变量，对象本身都会在堆上。 构造函数 构造函数带有你在初始化对象时会执行的程序代码。也就是新建一个对象时就会被执行。构造函数必须与累吗一样且没有返回类型。大部分人都是使用构造函数来初始化对象的状态。构造函数无法被继承。如果没写构造函数，编译器会帮你写一个没有参数的。构造方法可以重载。 构造函数链 super() 调用父类构造函数，编译器会在构造方法中隐式的加上super()调用。 this() 使用this()来从某个构造函数调用某个类的另外一个构造函数。this()只能用在构造函数中，且必须是第一句。super()和this()不能兼得，两者只有一个会是第一行。 对象的生命周期 局部变量只会存活在声明该变量的方法中实例变量的寿命与对象相同。如果对象还活着，则实例变量也会是活的。 释放引用对象 1.引用永久性的离开它的范围2.引用被赋值到其他的对象上3.直接将引用设定为null","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(八)——接口与抽象类","slug":"Head-First-Java读书笔记-八-——接口与抽象类","date":"2014-04-19T11:30:09.000Z","updated":"2019-02-22T08:12:22.910Z","comments":true,"path":"2014/04/19/Head-First-Java读书笔记-八-——接口与抽象类/","link":"","permalink":"https://www.laokamo.com/2014/04/19/Head-First-Java读书笔记-八-——接口与抽象类/","excerpt":"","text":"接口(interface) 100%纯抽象类 抽象类(abstract) 无法初始化的类没人能够创建出该类的实例 抽象方法 抽象方法没有实体不能在非抽象类中拥有抽象方法，反之可以 在Java中的所有类都是从Object这个类继承出来的 Object里有什么？ 12345678910class Object&#123; //对象是否 '相等' equals(Object o) //告诉你此对象是从哪里被初始化的 Class getClass() //对象的哈希码 int hashCode() //类名@hashcode toString()&#125; instanceof运算符 类型检查 Java不支持多重继承，因为多重继承会导致“致命方块”的问题 通过接口实现(implements)多重继承的功能 接口的方法带有public和abstract的意义，这两个修饰符是属于选择性的 如何判断应该设计类、子类、抽象类或接口呢？ 1.如果新的类无法对其他的类通过IS-A的测试时，就设计不继承其他的类2.只有在需要某类的的特殊化版本时，以覆盖或增加新的方法来继承现有的类3.当你需要定义一群子类的模板，又不想让程序初始化此模板时，设计出抽象的类给它们用4.如果想要定义出类可以扮演的角色，使用接口","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(七)——集成和多态","slug":"Head-First-Java读书笔记-七-——继承和多态","date":"2014-04-12T04:30:14.000Z","updated":"2019-02-22T08:09:32.475Z","comments":true,"path":"2014/04/12/Head-First-Java读书笔记-七-——继承和多态/","link":"","permalink":"https://www.laokamo.com/2014/04/12/Head-First-Java读书笔记-七-——继承和多态/","excerpt":"","text":"规划程序时要规划未来 继承 extends 当一个类继承自另外一个类时，就说 子类继承父类若你想知道某物是否应该继承另一物时，可以用 IS-A来检测，IS-A是单向的例如：三角形是一个多边形 子类会继承父类所有的publicl类型的实例变量和方法，但不会继承父类所有的private类型的变量和方法 继承的意义 1.避免了重复的程序代码2.定义出了共同的协议 覆盖的规则 1.参数必须一样，且返回类型必须兼容2.不能降低方法的存取权限 super关键字 多态 运行多态时，引用类型可以是实际类型的父类 方法的重载 重载的意义是两个方法的名称相同，但参数不同。1.返回类型可以不同2.不能只改变返回类型3.可以更改存储权限","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(六)——认识Java的API","slug":"Head-First-Java读书笔记-六-——认识Java的API","date":"2014-04-06T08:28:02.000Z","updated":"2019-02-22T08:06:06.506Z","comments":true,"path":"2014/04/06/Head-First-Java读书笔记-六-——认识Java的API/","link":"","permalink":"https://www.laokamo.com/2014/04/06/Head-First-Java读书笔记-六-——认识Java的API/","excerpt":"","text":"ArrayList 123456789101112131415161718class ArrayList&#123; //向list中加入对象参数 add(Object o) //在索引参数中移除对象 remove(int index) //移除对象 remove(Object o) //如果和对象参数匹配返回true contains(Object o) //如果list中没有元素返回true isEmpty() //返回对象参数的索引或-1 indexOf(Object o) //返回list中元素的个数 size() //返回当前索引参数的对象 get(int index)&#125; 数组和ArrayList的区别 数组创建时就必须确定大小存放对象给数组时必须指定位置ArrayList支持泛型 短运算符(&amp;&amp; ||) 长运算符(&amp; |) JDK API 在线文档","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(五)——编写程序","slug":"Head-First-Java读书笔记-五-——编写程序","date":"2014-04-05T01:01:33.000Z","updated":"2019-02-22T08:04:23.357Z","comments":true,"path":"2014/04/05/Head-First-Java读书笔记-五-——编写程序/","link":"","permalink":"https://www.laokamo.com/2014/04/05/Head-First-Java读书笔记-五-——编写程序/","excerpt":"","text":"编写过程 1.找出类应该做的事情2.列出实例变量和方法3.编写方法的伪代码4.编写方法的测试用程序5.实现类6.测试方法7.除错或重新设计 极限编程(XP) 1.多次经常性的小规模发布2.避免加入规格没有的功能3.先编写测试用的程序4.正常工作上下班5.随时随地重构6.保持简单7.结对编程 前置与后置的递增、递减操作符 x++ 等同于 x=x+1x-- 等同与 x=x-1 加强版的for循环 123for(String name:nameArray)&#123;&#125;","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(四)——方法操作实例变量","slug":"Head-First-Java读书笔记-四-——方法操作实例变量","date":"2014-03-30T12:57:06.000Z","updated":"2019-02-22T08:00:32.764Z","comments":true,"path":"2014/03/30/Head-First-Java读书笔记-四-——方法操作实例变量/","link":"","permalink":"https://www.laokamo.com/2014/03/30/Head-First-Java读书笔记-四-——方法操作实例变量/","excerpt":"","text":"类是对象的蓝图 方法会运用形参，调用的一方会传入实参 实参是传给方法的值。当它传入方法后就成了形参。 方法可以有返回值 void类型，代表并没有返回任何东西 Java是通过值传递的，也就是说通过拷贝传递 实例变量永远都会有默认值 实例变量与局部变量的差别 区别 实例变量 局部变量 声明处 类中 方法中 初始化 有默认值 无默认值 ==和equals() ==用来比较基本数据类型，或者判断两个引用是否引用同一个对象equals()用来判断两个对象是否在意义上相等","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(三)——primitive主数据类型和引用","slug":"Head-First-Java读书笔记-三-——primitive主数据类型和引用","date":"2014-03-29T02:52:12.000Z","updated":"2019-02-22T08:00:45.076Z","comments":true,"path":"2014/03/29/Head-First-Java读书笔记-三-——primitive主数据类型和引用/","link":"","permalink":"https://www.laokamo.com/2014/03/29/Head-First-Java读书笔记-三-——primitive主数据类型和引用/","excerpt":"","text":"变量 基本数据类型和引用 变量的规则 必须要有类型(type)必须要有名称(name) 基本数据类型 类型 位数 值域 boolean Java虚拟机决定 true or false char 16 bits 0 ~ 65535 byte 8 bits -128 ~ 127 short 16 bits -32768 ~ 32767 int 32 bits -2^31 ~ 2^31-1 long 64 bits -2^63 ~ 2^63-1 float 32 bits 范围规模可变 double 64 bits 范围规模可变 对象的声明、创建和赋值123456//1.声明一个引用变量,要求虚拟机分配空间给引用变量，并将此变量名为dog,此变量拥有被固定为Dog类型Dog dog = null;//2.创建对象，要求虚拟机分配堆空间给新建的Dog对象new Dog();//3.连接对象和引用Dog dog = new Dog(); 没有引用到任何对象的引用变量值为null 数组也是一个对象,能够使用位置索引来快速、随机的存取其中的元素1234Dog[] pets = new Dog[7];pets[0] = new Dog();pets[0].name = \"Fido\";pets[0].bark();","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(二)——类与对象","slug":"Head-First-Java读书笔记-二-——类与对象","date":"2014-03-23T01:49:07.000Z","updated":"2019-02-22T08:00:39.452Z","comments":true,"path":"2014/03/23/Head-First-Java读书笔记-二-——类与对象/","link":"","permalink":"https://www.laokamo.com/2014/03/23/Head-First-Java读书笔记-二-——类与对象/","excerpt":"","text":"类是对象的蓝图 它会告诉虚拟机如何创造某个类型的对象。 对象是靠类的模型塑造出来的 对象本身已知的事物成为实例变量 (instance variable)，它代表对象的状态，且该类型的每一个对象都会独立的拥有一份该类型的值；对象可以执行的动作成为方法 (methods) 1234567891011class Dog&#123; //实例变量 int size; String breed; String name; //方法 void bark()&#123; System.out.println(\"汪汪\"); &#125;&#125; 1234567class DogTestDrive&#123; public static void main(String[] args)&#123; Dog d = new Dog();//建立Dog对象 d.size = 40;//存取该对象的变量 d.bark();//调用方法 &#125;&#125; 全局变量 Java的面向对象概念中并没有全局变量这回事public static 全局方法public static final 常量","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(一)——基本概念","slug":"Head-First-Java读书笔记-一-——基本概念","date":"2014-03-22T06:24:20.000Z","updated":"2019-02-22T08:00:48.416Z","comments":true,"path":"2014/03/22/Head-First-Java读书笔记-一-——基本概念/","link":"","permalink":"https://www.laokamo.com/2014/03/22/Head-First-Java读书笔记-一-——基本概念/","excerpt":"","text":"前天，Java编程思想和Head First Java终于拿到手上了，真重！仔细想想，毕业后好像再也没有看过什么书了，下班后就玩玩游戏，看看电影，时间过得很快，但是脑子里就觉得缺少了什么东西，有一种漫无目的的感觉。 write-once / run-anywhere(一次编写、到处执行) Java的工作方式 源代码-&gt;编译器-&gt;字节码-&gt;Java虚拟机(JVM) 我要做的事情 编写源代码(*.java) -&gt; javac编译源代码 -&gt; 产生.class字节码文件 -&gt; java 启动虚拟机执行 Java的程序结构 什么是源文件？ 源文件(扩展名为.java)带有类的定义 什么是类？ 类用来表示程序的一个组件 什么是方法？ 类似于函数 类存在于原文件里面方法存在于类中语句存在于方法中 123456public class Dog&#123; //类 void bark()&#123;//方法 doSomething;//语句 ... &#125;&#125; 循环 while循环、do-while循环、for循环 比较运算符 &lt;（小于）、&gt; (大于) 、== (等于)","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"https://www.laokamo.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.laokamo.com/tags/读书笔记/"}]},{"title":"Java IDE安装","slug":"Java-IDE安装","date":"2014-03-19T13:16:22.000Z","updated":"2019-02-22T07:24:31.601Z","comments":true,"path":"2014/03/19/Java-IDE安装/","link":"","permalink":"https://www.laokamo.com/2014/03/19/Java-IDE安装/","excerpt":"","text":"百度了一下,Java的开发工具有几款热门的，比如Eclipse、IntelliJ IDEA，那就都试试看吧，反正都没用过～ 那我就用IntelliJ IDEA，比较好看！ 下载 从官网下载最新的安装包 解压 解压到/opt下 sudo tar -zxvf ideaIU-11.1.5d.tar.gz -C /opt 运行 解压后进入bin目录下在终端中输入 ./idea.sh 就启动了 OK,接下来正式要进入Java这个围城了！晚安","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.laokamo.com/tags/Java/"},{"name":"IDE","slug":"IDE","permalink":"https://www.laokamo.com/tags/IDE/"}]},{"title":"Ubuntu下配置Java环境","slug":"Ubuntu下配置Java环境","date":"2014-03-19T11:12:10.000Z","updated":"2019-02-22T07:31:30.599Z","comments":true,"path":"2014/03/19/Ubuntu下配置Java环境/","link":"","permalink":"https://www.laokamo.com/2014/03/19/Ubuntu下配置Java环境/","excerpt":"","text":"这两天，熟悉了一下Ubuntu系统，给我的感觉是字体渲染依然比Windows舒服，速度依然比Windows迅速。 话不多说，回到正题，今天我来配置一下Java环境。 1.下载JDK包 点击官网地址进行下载 2.解压 sudo tar zxvf jdk-7u72-linux-x64.tar.gz -C /usr/local/jdk 3.配置环境变量 1.sudo vi /etc/profile2.在末尾添加下面的环境变量,并保存 :wq1234JAVA_HOME=/usr/local/jdk/jdk1.7.0_72CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH 3.执行source /etc/profile 使配置文件生效 4.验证是否安装成功 打开terminal，分别执行java和javac命令，如果有列表显示，就说明安装成功啦！ 接下来就安装开发工具！","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.laokamo.com/tags/Java/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.laokamo.com/tags/Ubuntu/"}]},{"title":"再见Windows,你好Ubuntu","slug":"再见Windows-你好Ubuntu","date":"2014-03-17T13:12:25.000Z","updated":"2019-02-22T06:35:44.000Z","comments":true,"path":"2014/03/17/再见Windows-你好Ubuntu/","link":"","permalink":"https://www.laokamo.com/2014/03/17/再见Windows-你好Ubuntu/","excerpt":"","text":"大学时候无聊，在出租屋里玩过Ubuntu,没想到今天开始又要和你打交道了，兜兜转转又回来了。 话不多说，开干！ 1.准备工具 4G优盘一个 电脑一台 2.下载Ubuntu镜像 https://www.ubuntu.com/download/desktop我下的是12.04TLS版本 3.制作镜像 下载软碟通,并安装 点击 文件 -&gt; 打开 -&gt; ubuntu-12.04-desktop-amd64.iso 点击 启动 -&gt; 写入硬盘映像 选择U盘，先格式化，再写入，等待写入完成 4.安装 重启系统，选择启动方式为U盘，选择第二项Install Ubuntu,进入安装界面 balabala一直下一步，由于我是准备安装单系统，所以在安装类型页面选择清除整个磁盘并安装Ubuntu,并采用了自动分区 5.完成 重启后就可以进入新系统主页啦，成功！","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.laokamo.com/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"https://www.laokamo.com/tags/Linux/"}]},{"title":"2014年的目标","slug":"2014年的目标","date":"2014-03-16T06:51:50.000Z","updated":"2019-02-22T07:36:28.217Z","comments":true,"path":"2014/03/16/2014年的目标/","link":"","permalink":"https://www.laokamo.com/2014/03/16/2014年的目标/","excerpt":"","text":"既然要准备要转行了，怕自己中途放弃，就在这里订一个小小的目标吧！ 1.少玩Dota，虽然11平台马上就上1900分了～2.为了少玩游戏的话，远离Windows平台，装一个Linux系统3.看书 Head First Java(第二版)，百度上推荐菜鸟入门的 Java编程思想(第四版)，论坛里推荐的 4.去健身 加油！","categories":[],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://www.laokamo.com/tags/杂七杂八/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2014-03-15T02:24:17.000Z","updated":"2019-02-22T07:36:19.673Z","comments":true,"path":"2014/03/15/我的第一篇博客/","link":"","permalink":"https://www.laokamo.com/2014/03/15/我的第一篇博客/","excerpt":"","text":"Hello World!!!! 如同婴儿的第一声啼哭，奈斯！ 航海专业的我毕业3年多了，在船上也漂泊了近2年，每次伴随着发动机的震动声入眠时，都在心里默默的问自己，这是我想要的生活吗？ 不！ 所以我顶住了家人的压力，毅然决然的离开了那艘钢铁般的监狱，准备向程序员这条道路前行。 在此我要警醒自己，多读书、多看报、少吃零食、多碎觉！ 加油！","categories":[],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://www.laokamo.com/tags/杂七杂八/"}]}]}