{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"laokamo","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Nginx出现413 Request Entity Too Large错误解决方法","slug":"Nginx出现413-Request-Entity-Too-Large错误解决方法","date":"2016-10-21T14:20:41.000Z","updated":"2019-02-22T08:23:05.834Z","comments":true,"path":"2016/10/21/Nginx出现413-Request-Entity-Too-Large错误解决方法/","link":"","permalink":"http://yoursite.com/2016/10/21/Nginx出现413-Request-Entity-Too-Large错误解决方法/","excerpt":"","text":"最近公司有一个CMS项目，上传应用APK包时，小于1M的文件上传没问题，大于1M的文件会提示413 Request Entity Too Large错误。 一顿百度后发现，原来是Nginx限制了上传文件的大小(默认为1M)，在nginx中可以配置最大允许的文件大小 查看nginx文档 123Syntax:client_max_body_size size;Default:client_max_body_size 1m;Context: http, server, location Sets the maximum allowed size of the client request body, specified in the “Content-Length” request header field. If the size in a request exceeds the configured value, the 413 (Request Entity Too Large) error is returned to the client. Please be aware that browsers cannot correctly display this error. Setting size to 0 disables checking of client request body size. 那么解决起来就很简单了 1.打开配置文件 vim /conf/nginx.conf2.找到http{}3.添加client_max_body_size 200m; 这里改为200m，因为公司APK应用包基本100多m4.保存配置文件，并重启 ./nginx -s reload","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"Head First Java读书笔记(十一)——异常处理","slug":"Head-First-Java读书笔记-十一-——异常处理","date":"2014-04-27T03:16:21.000Z","updated":"2019-02-23T03:38:28.193Z","comments":true,"path":"2014/04/27/Head-First-Java读书笔记-十一-——异常处理/","link":"","permalink":"http://yoursite.com/2014/04/27/Head-First-Java读书笔记-十一-——异常处理/","excerpt":"","text":"调用有风险的方法时会发生什么？ 1.假设你调用了一个不是自己写的方法；2.该方法执行某些风险的任务，可能会在运行期间出状况；3.你必须认识到该方法的风险；4.你得写出可以在发生状况时加以处理的程序代码，未雨绸缪！ thorws 声明在方法上 throw 声明在catch中 try/catch12345try&#123; //危险动作&#125;catch(Exception ex)&#123; //尝试恢复&#125; 异常时一种Exception类型的对象 编译器会核对每件事，除了RuntimeExceptions 编译器所关心的时称为检查异常的异常。 finally 用来存放不管有没有异常都要执行的程序 流程 1.如果try块失败了，抛出异常，流程会马上转移到catch块。当catch块完成时，会执行finally块，当finally块完成时，就会继续执行其余部分。2.如果try块成功，流程会跳过catch块并移动到finally块，当finally完成时，就会继续执行其余的部分。3.如果try或catch块有return指令，finally还是会执行！程序会跳到finally然后再回到return指令 有多个catch块时要从小排到大","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"http://yoursite.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(十)——数字和静态","slug":"Head-First-Java读书笔记-十-——数字和静态","date":"2014-04-26T02:40:35.000Z","updated":"2019-02-23T03:13:09.648Z","comments":true,"path":"2014/04/26/Head-First-Java读书笔记-十-——数字和静态/","link":"","permalink":"http://yoursite.com/2014/04/26/Head-First-Java读书笔记-十-——数字和静态/","excerpt":"","text":"静态方法 一种不依靠实例变量也不需要对象的行为 例如: Math.min(88,86)静态的方法不能调用非静态的变量，因为静态的方法是通过类名来调用，所以静态的方法无法引用到该类的任何实例变量静态方法不能调用非静态的方法 静态变量 它的值对所有的实例来说都是相同的同一类所有的实例共享一份静态变量静态变量会在该类的任何静态方法执行之前就初始化 实例变量：每个实例一份静态变量：每个类一份 final关键字 final变量代表你不能改变它的值final方法代表你不能覆盖掉该方法final的类代表你不能集成该类(也就是创建它的子类) 常量 一个被标记为final的变量代表它一旦被初始化之后就不会改动，也就是说类加载之后静态final变量就会一直维持原值常量变量的名称应该都要大写字母","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"http://yoursite.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(九)——构造器与垃圾收集器","slug":"Head-First-Java读书笔记-九-——构造器与垃圾收集器","date":"2014-04-20T06:40:51.000Z","updated":"2019-02-22T08:17:49.094Z","comments":true,"path":"2014/04/20/Head-First-Java读书笔记-九-——构造器与垃圾收集器/","link":"","permalink":"http://yoursite.com/2014/04/20/Head-First-Java读书笔记-九-——构造器与垃圾收集器/","excerpt":"","text":"注意：内容含有死亡成份，12岁一下儿童需有家长陪同观赏对象有生死 栈(Stack) 方法调用和局部变量 堆(Heap) 所有的对象 实例变量 实例变量是被声明在类里而不是方法里面。它们代表每一个独立对象的’字段’。实例变量存在于所属的对象中。 局部变量 局部变量和方法的参数都是被声明在方法中。它们是暂时的，且声明周期只限于方法被放在栈上的的这段期间。 当调用一个方法时，该方法会放在调用栈的栈顶，实际被堆上栈的是堆栈块，它带有方法的状态，包括执行到哪一行程序以及所有的局部变量的值。 对象引用变量与基本数据类型都放在栈上。不管是实例变量或者局部变量，对象本身都会在堆上。 构造函数 构造函数带有你在初始化对象时会执行的程序代码。也就是新建一个对象时就会被执行。构造函数必须与累吗一样且没有返回类型。大部分人都是使用构造函数来初始化对象的状态。构造函数无法被继承。如果没写构造函数，编译器会帮你写一个没有参数的。构造方法可以重载。 构造函数链 super() 调用父类构造函数，编译器会在构造方法中隐式的加上super()调用。 this() 使用this()来从某个构造函数调用某个类的另外一个构造函数。this()只能用在构造函数中，且必须是第一句。super()和this()不能兼得，两者只有一个会是第一行。 对象的生命周期 局部变量只会存活在声明该变量的方法中实例变量的寿命与对象相同。如果对象还活着，则实例变量也会是活的。 释放引用对象 1.引用永久性的离开它的范围2.引用被赋值到其他的对象上3.直接将引用设定为null","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"http://yoursite.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(八)——接口与抽象类","slug":"Head-First-Java读书笔记-八-——接口与抽象类","date":"2014-04-19T11:30:09.000Z","updated":"2019-02-22T08:12:22.910Z","comments":true,"path":"2014/04/19/Head-First-Java读书笔记-八-——接口与抽象类/","link":"","permalink":"http://yoursite.com/2014/04/19/Head-First-Java读书笔记-八-——接口与抽象类/","excerpt":"","text":"接口(interface) 100%纯抽象类 抽象类(abstract) 无法初始化的类没人能够创建出该类的实例 抽象方法 抽象方法没有实体不能在非抽象类中拥有抽象方法，反之可以 在Java中的所有类都是从Object这个类继承出来的 Object里有什么？ 12345678910class Object&#123; //对象是否 '相等' equals(Object o) //告诉你此对象是从哪里被初始化的 Class getClass() //对象的哈希码 int hashCode() //类名@hashcode toString()&#125; instanceof运算符 类型检查 Java不支持多重继承，因为多重继承会导致“致命方块”的问题 通过接口实现(implements)多重继承的功能 接口的方法带有public和abstract的意义，这两个修饰符是属于选择性的 如何判断应该设计类、子类、抽象类或接口呢？ 1.如果新的类无法对其他的类通过IS-A的测试时，就设计不继承其他的类2.只有在需要某类的的特殊化版本时，以覆盖或增加新的方法来继承现有的类3.当你需要定义一群子类的模板，又不想让程序初始化此模板时，设计出抽象的类给它们用4.如果想要定义出类可以扮演的角色，使用接口","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"http://yoursite.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(七)——集成和多态","slug":"Head-First-Java读书笔记-七-——继承和多态","date":"2014-04-12T04:30:14.000Z","updated":"2019-02-22T08:09:32.475Z","comments":true,"path":"2014/04/12/Head-First-Java读书笔记-七-——继承和多态/","link":"","permalink":"http://yoursite.com/2014/04/12/Head-First-Java读书笔记-七-——继承和多态/","excerpt":"","text":"规划程序时要规划未来 继承 extends 当一个类继承自另外一个类时，就说 子类继承父类若你想知道某物是否应该继承另一物时，可以用 IS-A来检测，IS-A是单向的例如：三角形是一个多边形 子类会继承父类所有的publicl类型的实例变量和方法，但不会继承父类所有的private类型的变量和方法 继承的意义 1.避免了重复的程序代码2.定义出了共同的协议 覆盖的规则 1.参数必须一样，且返回类型必须兼容2.不能降低方法的存取权限 super关键字 多态 运行多态时，引用类型可以是实际类型的父类 方法的重载 重载的意义是两个方法的名称相同，但参数不同。1.返回类型可以不同2.不能只改变返回类型3.可以更改存储权限","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"http://yoursite.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(六)——认识Java的API","slug":"Head-First-Java读书笔记-六-——认识Java的API","date":"2014-04-06T08:28:02.000Z","updated":"2019-02-22T08:06:06.506Z","comments":true,"path":"2014/04/06/Head-First-Java读书笔记-六-——认识Java的API/","link":"","permalink":"http://yoursite.com/2014/04/06/Head-First-Java读书笔记-六-——认识Java的API/","excerpt":"","text":"ArrayList 123456789101112131415161718class ArrayList&#123; //向list中加入对象参数 add(Object o) //在索引参数中移除对象 remove(int index) //移除对象 remove(Object o) //如果和对象参数匹配返回true contains(Object o) //如果list中没有元素返回true isEmpty() //返回对象参数的索引或-1 indexOf(Object o) //返回list中元素的个数 size() //返回当前索引参数的对象 get(int index)&#125; 数组和ArrayList的区别 数组创建时就必须确定大小存放对象给数组时必须指定位置ArrayList支持泛型 短运算符(&amp;&amp; ||) 长运算符(&amp; |) JDK API 在线文档","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"http://yoursite.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(五)——编写程序","slug":"Head-First-Java读书笔记-五-——编写程序","date":"2014-04-05T01:01:33.000Z","updated":"2019-02-22T08:04:23.357Z","comments":true,"path":"2014/04/05/Head-First-Java读书笔记-五-——编写程序/","link":"","permalink":"http://yoursite.com/2014/04/05/Head-First-Java读书笔记-五-——编写程序/","excerpt":"","text":"编写过程 1.找出类应该做的事情2.列出实例变量和方法3.编写方法的伪代码4.编写方法的测试用程序5.实现类6.测试方法7.除错或重新设计 极限编程(XP) 1.多次经常性的小规模发布2.避免加入规格没有的功能3.先编写测试用的程序4.正常工作上下班5.随时随地重构6.保持简单7.结对编程 前置与后置的递增、递减操作符 x++ 等同于 x=x+1x-- 等同与 x=x-1 加强版的for循环 123for(String name:nameArray)&#123;&#125;","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"http://yoursite.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(四)——方法操作实例变量","slug":"Head-First-Java读书笔记-四-——方法操作实例变量","date":"2014-03-30T12:57:06.000Z","updated":"2019-02-22T08:00:32.764Z","comments":true,"path":"2014/03/30/Head-First-Java读书笔记-四-——方法操作实例变量/","link":"","permalink":"http://yoursite.com/2014/03/30/Head-First-Java读书笔记-四-——方法操作实例变量/","excerpt":"","text":"类是对象的蓝图 方法会运用形参，调用的一方会传入实参 实参是传给方法的值。当它传入方法后就成了形参。 方法可以有返回值 void类型，代表并没有返回任何东西 Java是通过值传递的，也就是说通过拷贝传递 实例变量永远都会有默认值 实例变量与局部变量的差别 区别 实例变量 局部变量 声明处 类中 方法中 初始化 有默认值 无默认值 ==和equals() ==用来比较基本数据类型，或者判断两个引用是否引用同一个对象equals()用来判断两个对象是否在意义上相等","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"http://yoursite.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(三)——primitive主数据类型和引用","slug":"Head-First-Java读书笔记-三-——primitive主数据类型和引用","date":"2014-03-29T02:52:12.000Z","updated":"2019-02-22T08:00:45.076Z","comments":true,"path":"2014/03/29/Head-First-Java读书笔记-三-——primitive主数据类型和引用/","link":"","permalink":"http://yoursite.com/2014/03/29/Head-First-Java读书笔记-三-——primitive主数据类型和引用/","excerpt":"","text":"变量 基本数据类型和引用 变量的规则 必须要有类型(type)必须要有名称(name) 基本数据类型 类型 位数 值域 boolean Java虚拟机决定 true or false char 16 bits 0 ~ 65535 byte 8 bits -128 ~ 127 short 16 bits -32768 ~ 32767 int 32 bits -2^31 ~ 2^31-1 long 64 bits -2^63 ~ 2^63-1 float 32 bits 范围规模可变 double 64 bits 范围规模可变 对象的声明、创建和赋值123456//1.声明一个引用变量,要求虚拟机分配空间给引用变量，并将此变量名为dog,此变量拥有被固定为Dog类型Dog dog = null;//2.创建对象，要求虚拟机分配堆空间给新建的Dog对象new Dog();//3.连接对象和引用Dog dog = new Dog(); 没有引用到任何对象的引用变量值为null 数组也是一个对象,能够使用位置索引来快速、随机的存取其中的元素1234Dog[] pets = new Dog[7];pets[0] = new Dog();pets[0].name = \"Fido\";pets[0].bark();","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"http://yoursite.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(二)——类与对象","slug":"Head-First-Java读书笔记-二-——类与对象","date":"2014-03-23T01:49:07.000Z","updated":"2019-02-22T08:00:39.452Z","comments":true,"path":"2014/03/23/Head-First-Java读书笔记-二-——类与对象/","link":"","permalink":"http://yoursite.com/2014/03/23/Head-First-Java读书笔记-二-——类与对象/","excerpt":"","text":"类是对象的蓝图 它会告诉虚拟机如何创造某个类型的对象。 对象是靠类的模型塑造出来的 对象本身已知的事物成为实例变量 (instance variable)，它代表对象的状态，且该类型的每一个对象都会独立的拥有一份该类型的值；对象可以执行的动作成为方法 (methods) 1234567891011class Dog&#123; //实例变量 int size; String breed; String name; //方法 void bark()&#123; System.out.println(\"汪汪\"); &#125;&#125; 1234567class DogTestDrive&#123; public static void main(String[] args)&#123; Dog d = new Dog();//建立Dog对象 d.size = 40;//存取该对象的变量 d.bark();//调用方法 &#125;&#125; 全局变量 Java的面向对象概念中并没有全局变量这回事public static 全局方法public static final 常量","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"http://yoursite.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Head First Java读书笔记(一)——基本概念","slug":"Head-First-Java读书笔记-一-——基本概念","date":"2014-03-22T06:24:20.000Z","updated":"2019-02-22T08:00:48.416Z","comments":true,"path":"2014/03/22/Head-First-Java读书笔记-一-——基本概念/","link":"","permalink":"http://yoursite.com/2014/03/22/Head-First-Java读书笔记-一-——基本概念/","excerpt":"","text":"前天，Java编程思想和Head First Java终于拿到手上了，真重！仔细想想，毕业后好像再也没有看过什么书了，下班后就玩玩游戏，看看电影，时间过得很快，但是脑子里就觉得缺少了什么东西，有一种漫无目的的感觉。 write-once / run-anywhere(一次编写、到处执行) Java的工作方式 源代码-&gt;编译器-&gt;字节码-&gt;Java虚拟机(JVM) 我要做的事情 编写源代码(*.java) -&gt; javac编译源代码 -&gt; 产生.class字节码文件 -&gt; java 启动虚拟机执行 Java的程序结构 什么是源文件？ 源文件(扩展名为.java)带有类的定义 什么是类？ 类用来表示程序的一个组件 什么是方法？ 类似于函数 类存在于原文件里面方法存在于类中语句存在于方法中 123456public class Dog&#123; //类 void bark()&#123;//方法 doSomething;//语句 ... &#125;&#125; 循环 while循环、do-while循环、for循环 比较运算符 &lt;（小于）、&gt; (大于) 、== (等于)","categories":[],"tags":[{"name":"Head First Java","slug":"Head-First-Java","permalink":"http://yoursite.com/tags/Head-First-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Java IDE安装","slug":"Java-IDE安装","date":"2014-03-19T13:16:22.000Z","updated":"2019-02-22T07:24:31.601Z","comments":true,"path":"2014/03/19/Java-IDE安装/","link":"","permalink":"http://yoursite.com/2014/03/19/Java-IDE安装/","excerpt":"","text":"百度了一下,Java的开发工具有几款热门的，比如Eclipse、IntelliJ IDEA，那就都试试看吧，反正都没用过～ 那我就用IntelliJ IDEA，比较好看！ 下载 从官网下载最新的安装包 解压 解压到/opt下 sudo tar -zxvf ideaIU-11.1.5d.tar.gz -C /opt 运行 解压后进入bin目录下在终端中输入 ./idea.sh 就启动了 OK,接下来正式要进入Java这个围城了！晚安","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"}]},{"title":"Ubuntu下配置Java环境","slug":"Ubuntu下配置Java环境","date":"2014-03-19T11:12:10.000Z","updated":"2019-02-22T07:31:30.599Z","comments":true,"path":"2014/03/19/Ubuntu下配置Java环境/","link":"","permalink":"http://yoursite.com/2014/03/19/Ubuntu下配置Java环境/","excerpt":"","text":"这两天，熟悉了一下Ubuntu系统，给我的感觉是字体渲染依然比Windows舒服，速度依然比Windows迅速。 话不多说，回到正题，今天我来配置一下Java环境。 1.下载JDK包 点击官网地址进行下载 2.解压 sudo tar zxvf jdk-7u72-linux-x64.tar.gz -C /usr/local/jdk 3.配置环境变量 1.sudo vi /etc/profile2.在末尾添加下面的环境变量,并保存 :wq1234JAVA_HOME=/usr/local/jdk/jdk1.7.0_72CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH 3.执行source /etc/profile 使配置文件生效 4.验证是否安装成功 打开terminal，分别执行java和javac命令，如果有列表显示，就说明安装成功啦！ 接下来就安装开发工具！","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"再见Windows,你好Ubuntu","slug":"再见Windows-你好Ubuntu","date":"2014-03-17T13:12:25.000Z","updated":"2019-02-22T06:35:44.000Z","comments":true,"path":"2014/03/17/再见Windows-你好Ubuntu/","link":"","permalink":"http://yoursite.com/2014/03/17/再见Windows-你好Ubuntu/","excerpt":"","text":"大学时候无聊，在出租屋里玩过Ubuntu,没想到今天开始又要和你打交道了，兜兜转转又回来了。 话不多说，开干！ 1.准备工具 4G优盘一个 电脑一台 2.下载Ubuntu镜像 https://www.ubuntu.com/download/desktop我下的是12.04TLS版本 3.制作镜像 下载软碟通,并安装 点击 文件 -&gt; 打开 -&gt; ubuntu-12.04-desktop-amd64.iso 点击 启动 -&gt; 写入硬盘映像 选择U盘，先格式化，再写入，等待写入完成 4.安装 重启系统，选择启动方式为U盘，选择第二项Install Ubuntu,进入安装界面 balabala一直下一步，由于我是准备安装单系统，所以在安装类型页面选择清除整个磁盘并安装Ubuntu,并采用了自动分区 5.完成 重启后就可以进入新系统主页啦，成功！","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"2014年的目标","slug":"2014年的目标","date":"2014-03-16T06:51:50.000Z","updated":"2019-02-22T07:36:28.217Z","comments":true,"path":"2014/03/16/2014年的目标/","link":"","permalink":"http://yoursite.com/2014/03/16/2014年的目标/","excerpt":"","text":"既然要准备要转行了，怕自己中途放弃，就在这里订一个小小的目标吧！ 1.少玩Dota，虽然11平台马上就上1900分了～2.为了少玩游戏的话，远离Windows平台，装一个Linux系统3.看书 Head First Java(第二版)，百度上推荐菜鸟入门的 Java编程思想(第四版)，论坛里推荐的 4.去健身 加油！","categories":[],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://yoursite.com/tags/杂七杂八/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2014-03-15T02:24:17.000Z","updated":"2019-02-22T07:36:19.673Z","comments":true,"path":"2014/03/15/我的第一篇博客/","link":"","permalink":"http://yoursite.com/2014/03/15/我的第一篇博客/","excerpt":"","text":"Hello World!!!! 如同婴儿的第一声啼哭，奈斯！ 航海专业的我毕业3年多了，在船上也漂泊了近2年，每次伴随着发动机的震动声入眠时，都在心里默默的问自己，这是我想要的生活吗？ 不！ 所以我顶住了家人的压力，毅然决然的离开了那艘钢铁般的监狱，准备向程序员这条道路前行。 在此我要警醒自己，多读书、多看报、少吃零食、多碎觉！ 加油！","categories":[],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://yoursite.com/tags/杂七杂八/"}]}]}